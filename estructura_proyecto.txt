FugasDetectionSystem/
 .github/
   workflows/
 Documentación/
 FugasDetectionSystem.ApiAppTecnicos/
   Controllers/
     AgendaController.cs
     /*
     ï»¿using Microsoft.AspNetCore.Mvc;
     
     // For more information on enabling Web API for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860
     
     namespace FugasDetectionSystem.ApiAppTecnicos.Controllers
     {
         [Route("api/[controller]")]
         [ApiController]
         public class AgendaController : ControllerBase
         {
             // GET: api/<AgendaController>
             [HttpGet]
             public IEnumerable<string> Get()
             {
                 return new string[] { "value1", "value2" };
             }
     
             // GET api/<AgendaController>/5
             [HttpGet("{id}")]
             public string Get(int id)
             {
                 return "value";
             }
     
             // POST api/<AgendaController>
             [HttpPost]
             public void Post([FromBody] string value)
             {
             }
     
             // PUT api/<AgendaController>/5
             [HttpPut("{id}")]
             public void Put(int id, [FromBody] string value)
             {
             }
     
             // DELETE api/<AgendaController>/5
             [HttpDelete("{id}")]
             public void Delete(int id)
             {
             }
         }
     }
     */

   Program.cs
   /*
   
   namespace FugasDetectionSystem.ApiAppTecnicos
   {
       public class Program
       {
           public static void Main(string[] args)
           {
               var builder = WebApplication.CreateBuilder(args);
   
               // Add services to the container.
   
               builder.Services.AddControllers();
               // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
               builder.Services.AddEndpointsApiExplorer();
               builder.Services.AddSwaggerGen();
   
               var app = builder.Build();
   
               // Configure the HTTP request pipeline.
               if (app.Environment.IsDevelopment())
               {
                   app.UseSwagger();
                   app.UseSwaggerUI();
               }
   
               app.UseHttpsRedirection();
   
               app.UseAuthorization();
   
   
               app.MapControllers();
   
               app.Run();
           }
       }
   }
   */

 FugasDetectionSystem.Application/
   Managers/
     TecnicoManager.cs
     /*
     ï»¿using FugasDetectionSystem.Common.Models;
     using FugasDetectionSystem.Domain.Entities;
     using FugasDetectionSystem.Domain.Interfaces;
     
     
     namespace FugasDetectionSystem.Application.Managers
     {
         public class TecnicoManager
         {
             private readonly ITecnicoRepository _tecnicoRepository;
     
             public TecnicoManager(ITecnicoRepository tecnicoRepository)
             {
                 _tecnicoRepository = tecnicoRepository;
             }
     
             public async Task<Result<List<Tecnico>>> GetAllTecnicosAsync()
             {
                 try
                 {
                     var tecnicos = await _tecnicoRepository.GetAllAsync();
                     return Result<List<Tecnico>>.Success(tecnicos.ToList());
                 }
                 catch (Exception ex)
                 {
                     return Result<List<Tecnico>>.Failure(ex.Message);
                 }
             }
     
     
         }
     }
     */

 FugasDetectionSystem.BotWorker/
   Program.cs
   /*
   using FugasDetectionSystem.Domain.Interfaces;
   using FugasDetectionSystem.Infrastructure.Services.Telegram;
   using FugasDetectionSystem.Infrastructure.Data;
   using FugasDetectionSystem.Domain.Repositories;
   using FugasDetectionSystem.Infrastructure.Services.Telegram.Interfaces;
   
   namespace FugasDetectionSystem.BotWorker
   {
       public class Program
       {
           public static void Main(string[] args)
           {
               var builder = Host.CreateApplicationBuilder(args);
   
               // Agregar configuración
               builder.Configuration.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);
   
               // Configurar la inyección de dependencias
               builder.Services.AddSingleton<ITelegramBotService>(provider =>
               {
                   // Asegúrate de que tu token de la API de Telegram esté en tu archivo appsettings.json
                   var token = builder.Configuration["TelegramApiToken"];
   
                   // Si el token es nulo, lanzar una excepción clara para indicar que falta la configuración
                   if (string.IsNullOrEmpty(token))
                   {
                       throw new ArgumentNullException(nameof(token), "El token de la API de Telegram no puede ser nulo o vacío. Asegúrate de configurarlo en appsettings.json o en las variables de entorno.");
                   }
   
                   return new TelegramBotService(token);
               });
   
               // Registro de la cadena de conexión y repositorios
               var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
   
               if (connectionString == null)
               {
                   throw new ArgumentNullException(nameof(connectionString), "La cadena de conexión no puede ser nula. Asegúrate de configurarla en appsettings.json o en las variables de entorno.");
               }
   
               // Registro de DatabaseSettings con la cadena de conexión.
               var databaseSettings = new DatabaseSettings(connectionString);
               builder.Services.AddSingleton<IDatabaseSettings>(databaseSettings);
   
   
   
               builder.Services.AddSingleton<ITecnicoRepository>( provider => { 
                   return new TecnicoRepository(databaseSettings);
               });
   
               builder.Services.AddHostedService<Worker>();
   
               // Construir y ejecutar la aplicación
               var host = builder.Build();
               host.Run();
           }
       }
   }
   */

   Worker.cs
   /*
   using Telegram.Bot.Types;
   using Telegram.Bot;
   using FugasDetectionSystem.Domain.Interfaces;
   using FugasDetectionSystem.Domain.Entities;
   using System.Diagnostics.CodeAnalysis;
   using Telegram.Bot.Types.Enums;
   using FugasDetectionSystem.Infrastructure.Services.Telegram.Interfaces;
   using FugasDetectionSystem.Application.Managers;
   
   namespace FugasDetectionSystem.BotWorker
   {
       public class Worker(ILogger<Worker> logger, ITelegramBotService telegramBotService, ITecnicoRepository tecnicoRepository) : BackgroundService
       {
           private readonly ILogger<Worker> _logger = logger;
           private readonly ITelegramBotService _telegramBotService = telegramBotService;
           private readonly ITecnicoRepository _tecnicoRepository = tecnicoRepository;
   
           protected override async Task ExecuteAsync(CancellationToken stoppingToken)
           {
               // En algún lugar dentro de tu bot worker
               var result = await tecnicoManager.GetAllTecnicosAsync();
               if (result.IsSuccess)
               {
                   // Puedes trabajar con result.Value que será una List<Tecnico>
               }
               else
               {
                   // Manejar el error, result.ErrorMessage tendrá la descripción del error
               }
   
               _telegramBotService.StartReceiving(HandleUpdateAsync, HandleErrorAsync);
   
               while (!stoppingToken.IsCancellationRequested)
               {
                   _logger.LogInformation("Worker running at: {time}", DateTimeOffset.Now);
                   await Task.Delay(1000, stoppingToken);
               }
   
               _telegramBotService.StopReceiving();
           }
   
           private async Task HandleUpdateAsync(ITelegramBotClient botClient, Update update, CancellationToken cancellationToken)
           {
   
               //verifica el tipo de mensaje voz, texto, imagen y otros los otros no se tomaran en cuenta... no se lo que son... almacenarlos para estudiarlos en un log cuando lleguen..
   
               if (update.Message != null)
               {
                   /*if (update.Message.Type == MessageType.Photo){}
                   if (update.Message.Type == MessageType.Video){}
                   if (update.Message.Type == MessageType.Voice){}
                   */
                   if (update.Message.Type == MessageType.Text){
   
                   }
   
                   // Extraer el chatId del mensaje recibido
                   var chatId = update.Message.Chat.Id;
   
                   // Preparar el texto de la respuesta
                   string responseText = "(" + update.Message.Type.ToString() + ") Estamos trabajando en este servicio. Para más información visita okFugas.cl";
   
                   // Enviar el mensaje de respuesta
                   await botClient.SendTextMessageAsync(chatId, responseText, cancellationToken: cancellationToken);
   
               }
   
   
           }
   
   
           private Task HandleErrorAsync(ITelegramBotClient botClient, Exception exception, CancellationToken cancellationToken)
           {
               // Aquí va tu lógica para manejar errores
               return Task.CompletedTask;
           }
       }
   }
   */

 FugasDetectionSystem.Common/
   Models/
     Result.cs
     /*
     ï»¿namespace FugasDetectionSystem.Common.Models
     {
         public class Result<T>
         {
             public bool IsSuccess { get; }
             public T Value { get; }
             public string ErrorMessage { get; }
             public Exception Exception { get; }
     
             protected Result(T value, bool isSuccess, string errorMessage, Exception exception)
             {
                 Value = value;
                 IsSuccess = isSuccess;
                 ErrorMessage = errorMessage;
                 Exception = exception;
             }
     
             public static Result<T> Success(T value) => new(value, true, null, null);
             public static Result<T> Failure(string errorMessage, Exception exception = null) => new(default, false, errorMessage, exception);
         }
     }
     */

 FugasDetectionSystem.Domain/
   Entities/
     BloqueHorario.cs
     /*
     ï»¿namespace FugasDetectionSystem.Domain.Entities
     {
         // Clase para representar los bloques horarios en cada dÃ­a
         public class BloqueHorario(string inicio, string termino)
         {
             public string Inicio { get; set; } = inicio;
             public string Termino { get; set; } = termino;
         }
     }
     */

     DisponibilidadCalendario.cs
     /*
     ï»¿namespace FugasDetectionSystem.Domain.Entities
     {
         // Clase para representar la disponibilidad, ajusta segÃºn tus necesidades
         public class DisponibilidadCalendario
         {
             public DisponibilidadCalendario(IEnumerable<DisponibilidadTecnico> disponibilidades)
             {
                 foreach(var disponibilidad in disponibilidades)
                 {
                     var inicio = disponibilidad.HoraInicio.ToString();
                     var termino = disponibilidad.HoraFin.ToString();
                     switch (disponibilidad.Fecha)
                     {
                         case "Lunes":
                             Lunes.Add(new BloqueHorario(inicio, termino));
                             break;
                         case "Martes":
                             Martes.Add(new BloqueHorario(inicio, termino));
                             break;
                         case "Miercoles":
                             Miercoles.Add(new BloqueHorario(inicio, termino));
                             break;
                         case "Jueves":
                             Jueves.Add(new BloqueHorario(inicio, termino));
                             break;
                         case "Viernes":
                             Viernes.Add(new BloqueHorario(inicio, termino));
                             break;
                         case "Sabado":
                             Sabado.Add(new BloqueHorario(inicio, termino));
                             break;
                         case "Domingo":
                             Domingo.Add(new BloqueHorario(inicio, termino));
                             break;
                     }
                 }
             }
     
             public List<BloqueHorario> Lunes { get; set; } = [];
             public List<BloqueHorario> Martes { get; set; } = [];
             public List<BloqueHorario> Miercoles { get; set; } = [];
             public List<BloqueHorario> Jueves { get; set; } = [];
             public List<BloqueHorario> Viernes { get; set; } = [];
             public List<BloqueHorario> Sabado { get; set; } = [];
             public List<BloqueHorario> Domingo { get; set; } = [];
         }
     }
     */

     DisponibilidadTecnico.cs
     /*
     ï»¿namespace FugasDetectionSystem.Domain.Entities
     {
         public class DisponibilidadTecnico
         {
             public int DisponibilidadID { get; set; }
             public int TecnicoID { get; set; }
             public string Fecha { get; set; } = string.Empty;
             public string HoraInicio { get; set; } = string.Empty;
             public string HoraFin { get; set; } = string.Empty;
         }
     }
     */

     Tecnico.cs
     /*
     ï»¿namespace FugasDetectionSystem.Domain.Entities
     {
         public class Tecnico
         {
             public int TecnicoID { get; set; }
             public string Nombre { get; set; } = string.Empty;
             public string Apellido { get; set; } = string.Empty;
             public string Especialidad { get; set; } = string.Empty;
             public string CorreoElectronico { get; set; } = string.Empty;
             public string Telefono { get; set; } = string.Empty;
             public IEnumerable<DisponibilidadTecnico>? Disponibilidad { get; set; }
             public DisponibilidadCalendario? Calendario { get; }
             
         }
     
     }
     */

   Interfaces/
     IDatabaseSettings.cs
     /*
     ï»¿using System;
     using System.Collections.Generic;
     using System.Linq;
     using System.Text;
     using System.Threading.Tasks;
     
     namespace FugasDetectionSystem.Domain.Interfaces
     {
         public interface IDatabaseSettings
         {
             string ConnectionString { get; }
         }
     }
     */

     IDisponibilidadTecnicoRepository.cs
     /*
     ï»¿using FugasDetectionSystem.Domain.Entities;
     using System;
     using System.Collections.Generic;
     using System.Linq;
     using System.Text;
     using System.Threading.Tasks;
     
     namespace FugasDetectionSystem.Domain.Interfaces
     {
         public interface IDisponibilidadTecnicoRepository
         {
             // MÃ©todo para agregar una nueva disponibilidad de tÃ©cnico a la base de datos.
             void AddDisponibilidadTecnico(DisponibilidadTecnico disponibilidadTecnico);
     
             // MÃ©todo para obtener una lista de todas las disponibilidades de tÃ©cnicos.
             List<DisponibilidadTecnico> GetDisponibilidadesTecnico();
     
             // MÃ©todo para obtener una Ãºnica disponibilidad de tÃ©cnico por su identificador.
             DisponibilidadTecnico GetDisponibilidadTecnico(int disponibilidadTecnicoId);
     
             // MÃ©todo para actualizar la informaciÃ³n de una disponibilidad de tÃ©cnico existente.
             void UpdateDisponibilidadTecnico(DisponibilidadTecnico disponibilidadTecnico);
     
             // MÃ©todo para eliminar una disponibilidad de tÃ©cnico de la base de datos por su identificador.
             void DeleteDisponibilidadTecnico(int disponibilidadTecnicoId);
         }
     }
     */

     ILogger.cs
     /*
     ï»¿using System;
     using System.Collections.Generic;
     using System.Linq;
     using System.Text;
     using System.Threading.Tasks;
     
     namespace FugasDetectionSystem.Domain.Interfaces
     {
         public interface ILogger
         {
             void LogInfo(string message);
             void LogWarning(string message);
             void LogError(string message, Exception ex);
         }
     
     }
     */

     ITecnicoRepository.cs
     /*
     ï»¿using FugasDetectionSystem.Domain.Entities;
     using System.Collections.Generic;
     
     namespace FugasDetectionSystem.Domain.Interfaces
     {
         public interface ITecnicoRepository
         {
             // MÃ©todo para verificar si la tabla de tÃ©cnicos existe.
             //bool TableExists();
     
             // MÃ©todo para crear la tabla de tÃ©cnicos si no existe.
             //void CreateTable();
     
             // MÃ©todo para crear la tabla de tÃ©cnicos si no existe.
             //void CreateCRUDStoreProcedure();
     
             // MÃ©todo para agregar un nuevo tÃ©cnico a la base de datos.
             Task AddAsync(Tecnico tecnico);
     
             // MÃ©todo para obtener una lista de todos los tÃ©cnicos.
             Task<IEnumerable<Tecnico>> GetAllAsync();
     
             // MÃ©todo para obtener un Ãºnico tÃ©cnico por su identificador.
             Task<Tecnico> GetByIdAsync(int tecnicoId);
     
             // MÃ©todo para actualizar la informaciÃ³n de un tÃ©cnico existente.
             Task UpdateAsync(Tecnico tecnico);
     
             // MÃ©todo para eliminar un tÃ©cnico de la base de datos por su identificador.
             Task DeleteAsync(int tecnicoId);
         }
     }
     */

 FugasDetectionSystem.Infrastructure/
   Data/
     DatabaseSettings.cs
     /*
     ï»¿using FugasDetectionSystem.Domain.Interfaces;
     using System;
     using System.Collections.Generic;
     using System.Linq;
     using System.Text;
     using System.Threading.Tasks;
     
     namespace FugasDetectionSystem.Infrastructure.Data
     {
         public class DatabaseSettings(string connectionString) : IDatabaseSettings
         {
             //Cadena de conexiÃ³n
             public string ConnectionString { get; } = connectionString;
         }
     }
     */

     FugasDbContext.cs
     /*
     ï»¿using FugasDetectionSystem.Domain.Interfaces;
     using Microsoft.EntityFrameworkCore;
     
     namespace FugasDetectionSystem.Infrastructure.Data
     {
         public class FugasDbContext(IDatabaseSettings databaseSettings) : DbContext
         {
             private readonly IDatabaseSettings _databaseSettings = databaseSettings;
     
             public IDatabaseSettings DatabaseSettings => _databaseSettings;
         }
     }
     */

   Exceptions/
     RepositoryException.cs
     /*
     ï»¿using System;
     
     namespace FugasDetectionSystem.Infrastructure.Exceptions
     {
         // Extiende de la clase base 'Exception'
         public class RepositoryException : Exception
         {
             // Propiedad adicional en caso de que quieras incluir un cÃ³digo de error especÃ­fico para tu repositorio
             public int ErrorCode { get; }
     
             // Constructor que solo toma un mensaje
             public RepositoryException(string message) : base(message)
             {
             }
     
             // Constructor que toma un mensaje y la excepciÃ³n original
             public RepositoryException(string message, Exception innerException) : base(message, innerException)
             {
             }
     
             // Constructor que toma un mensaje, un cÃ³digo de error y la excepciÃ³n original
             public RepositoryException(string message, int errorCode, Exception innerException)
                 : base(message, innerException)
             {
                 ErrorCode = errorCode;
             }
         }
     }
     */

   Logging/
     AzureMonitorLogger.cs
     /*
     ï»¿using System;
     using System.Collections.Generic;
     using System.Linq;
     using System.Text;
     using System.Threading.Tasks;
     
     namespace FugasDetectionSystem.Infrastructure.Logging
     {
         internal class AzureMonitorLogger
         {
         }
     }
     */

     CloudWatchLogger.cs
     /*
     ï»¿using System;
     using System.Collections.Generic;
     using System.Linq;
     using System.Text;
     using System.Threading.Tasks;
     
     namespace FugasDetectionSystem.Infrastructure.Logging
     {
         internal class CloudWatchLogger
         {
         }
     }
     */

     GoogleCloudLogger.cs
     /*
     ï»¿using System;
     using System.Collections.Generic;
     using System.Linq;
     using System.Text;
     using System.Threading.Tasks;
     
     namespace FugasDetectionSystem.Infrastructure.Logging
     {
         internal class GoogleCloudLogger
         {
         }
     }
     */

     Log4netLogger.cs
     /*
     ï»¿using FugasDetectionSystem.Domain.Interfaces;
     using log4net;
     using log4net.Config;
     using System;
     using System.IO;
     using System.Reflection;
     
     namespace FugasDetectionSystem.Infrastructure.Logging
     {
     
         public class Log4netLogger : ILogger
         {
             private readonly ILog _log;
     
             public Log4netLogger()
             {
                 var logRepository = LogManager.GetRepository(Assembly.GetEntryAssembly());
                 XmlConfigurator.Configure(logRepository, new FileInfo("log4net.config"));
                 _log = LogManager.GetLogger(typeof(Log4netLogger));
             }
     
             public void LogInfo(string message)
             {
                 _log.Info(message);
             }
     
             public void LogWarning(string message)
             {
                 _log.Warn(message);
             }
     
             public void LogError(string message, Exception ex)
             {
                 _log.Error(message, ex);
             }
         }
     
     }
     */

     NLogLogger.cs
     /*
     ï»¿using System;
     using System.Collections.Generic;
     using System.Linq;
     using System.Text;
     using System.Threading.Tasks;
     
     namespace FugasDetectionSystem.Infrastructure.Logging
     {
         internal class NLogLogger
         {
         }
     }
     */

     SerilogLogger.cs
     /*
     ï»¿using System;
     using System.Collections.Generic;
     using System.Linq;
     using System.Text;
     using System.Threading.Tasks;
     
     namespace FugasDetectionSystem.Infrastructure.Logging
     {
         internal class SerilogLogger
         {
         }
     }
     */

   Repositories/
     BaseRepository.cs
     /*
     ï»¿using FugasDetectionSystem.Domain.Interfaces;
     using FugasDetectionSystem.Infrastructure.Data;
     using FugasDetectionSystem.Infrastructure.Exceptions;
     using Microsoft.Data.SqlClient;
     using Microsoft.IdentityModel.Tokens;
     using System.Data;
     
     namespace FugasDetectionSystem.Infrastructure.repositories
     {
         public abstract class BaseRepository
         {
             protected string ConnectionString { get; private set; }
     
             protected BaseRepository(IDatabaseSettings databaseSettings)
             {
                 ConnectionString = databaseSettings.ConnectionString;
             }
     
             protected SqlConnection GetOpenConnection()
             {
                 var connection = new SqlConnection(ConnectionString);
                 connection.Open();
                 return connection;
             }
     
             protected static SqlCommand CreateCommand(SqlConnection connection, string storedProcedure, CommandType commandType = CommandType.StoredProcedure)
             {
                 var command = new SqlCommand(storedProcedure, connection)
                 {
                     CommandType = commandType
                 };
                 return command;
             }
     
             protected static void HandleException(Exception exception)
             {
                 if (exception is SqlException sqlEx)
                 {
                     // Manejo especÃ­fico para SqlException
                     LogError(sqlEx);
                     throw new RepositoryException("OcurriÃ³ un error especÃ­fico de SQL.", sqlEx.Number, sqlEx);
                 }
                 else
                 {
                     // Manejo general para otras excepciones
                     LogError(exception);
                     throw new RepositoryException("OcurriÃ³ un error inesperado en el repositorio.", exception);
                 }
             }
     
             private static void LogError(Exception exception)
             {
                 // Implementa tu lÃ³gica de registro aquÃ­. Ejemplo usando un sistema de registro:
                 // Log.Error(exception, "Mensaje de error con contexto adicional");
                 Console.WriteLine(exception.ToString()); // Sustituye esto por tu mecanismo de registro real.
             }
         }
     
     }
     
     
     */

     DisponibilidadTecnicoRepository.cs
     /*
     ï»¿using FugasDetectionSystem.Domain.Entities;
     using FugasDetectionSystem.Domain.Interfaces;
     using Microsoft.Data.SqlClient;
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Linq;
     using System.Text;
     using System.Threading.Tasks;
     
     namespace FugasDetectionSystem.Infrastructure.repositories
     {
         public class DisponibilidadTecnicoRepository : IDisponibilidadTecnicoRepository
         {
             private readonly string _connectionString;
     
             public DisponibilidadTecnicoRepository(IDatabaseSettings databaseSettings)
             {
                 _connectionString = databaseSettings.ConnectionString;
             }
     
             public List<DisponibilidadTecnico> GetDisponibilidadesTecnico()
             {
                 var disponibilidadesTecnico = new List<DisponibilidadTecnico>();
     
                 try
                 {
                     using var connection = new SqlConnection(_connectionString);
     
                     connection.Open();
     
                     using var command = new SqlCommand("ConsultarDisponibilidadesTecnico", connection);
     
                     // Especifica que el tipo de comando es un procedimiento almacenado.
                     command.CommandType = CommandType.StoredProcedure;
     
                     using var reader = command.ExecuteReader();
     
                     while (reader.Read())
                     {
                         var disponibilidadTecnico = new DisponibilidadTecnico
                         {
                             DisponibilidadID = reader.GetInt32(reader.GetOrdinal("DisponibilidadID")),
                             TecnicoID = reader.GetInt32(reader.GetOrdinal("TecnicoID")),
                             Fecha = reader.IsDBNull(reader.GetOrdinal("Fecha")) ? string.Empty : reader.GetString(reader.GetOrdinal("Fecha")),
                             HoraInicio = reader.IsDBNull(reader.GetOrdinal("HoraInicio")) ? string.Empty : reader.GetString(reader.GetOrdinal("HoraInicio")),
                             HoraFin = reader.IsDBNull(reader.GetOrdinal("HoraFin")) ? string.Empty : reader.GetString(reader.GetOrdinal("HoraFin"))
                         };
     
                         disponibilidadesTecnico.Add(disponibilidadTecnico);
                     }
                 }
                 catch (SqlException ex)
                 {
                     // Maneja la excepciÃ³n de SQL aquÃ­.
                     Console.WriteLine($"OcurriÃ³ un error de SQL: {ex.Message}");
                 }
                 catch (Exception ex)
                 {
                     // Maneja cualquier otro tipo de excepciÃ³n aquÃ­.
                     Console.WriteLine($"OcurriÃ³ un error inesperado: {ex.Message}");
                 }
     
                 return disponibilidadesTecnico;
             }
     
             public DisponibilidadTecnico GetDisponibilidadTecnico(int disponibilidadTecnicoId)
             {
                 DisponibilidadTecnico disponibilidadTecnico = new();
     
                 try
                 {
                     using var connection = new SqlConnection(_connectionString);
     
                     connection.Open();
     
                     using var command = new SqlCommand("ConsultarDisponibilidadTecnicoPorID", connection);
     
                     // Especifica que el tipo de comando es un procedimiento almacenado.
                     command.CommandType = CommandType.StoredProcedure;
     
                     // AÃ±ade los parÃ¡metros esperados por el procedimiento almacenado.
                     command.Parameters.AddWithValue("@DisponibilidadID", disponibilidadTecnicoId);
     
                     using var reader = command.ExecuteReader();
     
                     if (reader.Read())
                     {
                         disponibilidadTecnico = new DisponibilidadTecnico
                         {
                             DisponibilidadID = reader.GetInt32(reader.GetOrdinal("DisponibilidadID")),
                             TecnicoID = reader.GetInt32(reader.GetOrdinal("TecnicoID")),
                             Fecha = reader.IsDBNull(reader.GetOrdinal("Fecha")) ? string.Empty : reader.GetString(reader.GetOrdinal("Fecha")),
                             HoraInicio = reader.IsDBNull(reader.GetOrdinal("HoraInicio")) ? string.Empty : reader.GetString(reader.GetOrdinal("HoraInicio")),
                             HoraFin = reader.IsDBNull(reader.GetOrdinal("HoraFin")) ? string.Empty : reader.GetString(reader.GetOrdinal("HoraFin"))
                         };
                     }
                 }
                 catch (SqlException ex)
                 {
                     // Maneja la excepciÃ³n de SQL aquÃ­.
                     Console.WriteLine($"OcurriÃ³ un error de SQL: {ex.Message}");
                 }
                 catch (Exception ex)
                 {
                     // Maneja cualquier otro tipo de excepciÃ³n aquÃ­.
                     Console.WriteLine($"OcurriÃ³ un error inesperado: {ex.Message}");
                 }
     
                 return disponibilidadTecnico;
             }
     
             public void AddDisponibilidadTecnico(DisponibilidadTecnico disponibilidadTecnico)
             {
                 try
                 {
                     using var connection = new SqlConnection(_connectionString);
     
                     connection.Open();
     
                     using var command = new SqlCommand("InsertarDisponibilidadTecnico", connection);
     
                     // Especifica que el tipo de comando es un procedimiento almacenado.
                     command.CommandType = CommandType.StoredProcedure;
     
                     // AÃ±ade los parÃ¡metros esperados por el procedimiento almacenado.
                     command.Parameters.AddWithValue("@TecnicoID", disponibilidadTecnico.TecnicoID);
                     command.Parameters.AddWithValue("@Fecha", disponibilidadTecnico.Fecha ?? string.Empty);
                     command.Parameters.AddWithValue("@HoraInicio", disponibilidadTecnico.HoraInicio ?? string.Empty);
                     command.Parameters.AddWithValue("@HoraFin", disponibilidadTecnico.HoraFin ?? string.Empty);
     
                     // AÃ±ade un parÃ¡metro para recibir el valor de retorno del procedimiento almacenado.
                     var returnParameter = command.Parameters.Add("@ReturnVal", SqlDbType.Int);
                     returnParameter.Direction = ParameterDirection.ReturnValue;
     
                     command.ExecuteNonQuery();
     
                     int result = (int)returnParameter.Value;
                     if (result == 0)
                     {
                         // Manejar el caso en el que no se pudo insertar el tÃ©cnico.
                         Console.WriteLine("No se pudo insertar la disponibilidad.");
                     }
                     else
                     {
                         Console.WriteLine("Disponibilidad insertada con Ã©xito.");
                     }
     
                 }
                 catch (SqlException ex)
                 {
                     // Maneja la excepciÃ³n de SQL aquÃ­.
                     Console.WriteLine($"OcurriÃ³ un error de SQL: {ex.Message}");
                 }
                 catch (Exception ex)
                 {
                     // Maneja cualquier otro tipo de excepciÃ³n aquÃ­.
                     Console.WriteLine($"OcurriÃ³ un error inesperado: {ex.Message}");
                 }
             }
     
             public void UpdateDisponibilidadTecnico(DisponibilidadTecnico disponibilidadTecnico)
             {
                 try
                 {
                     using var connection = new SqlConnection(_connectionString);
     
                     connection.Open();
     
                     using var command = new SqlCommand("ActualizarDisponibilidadTecnico", connection);
     
                     // Especifica que el tipo de comando es un procedimiento almacenado.
                     command.CommandType = CommandType.StoredProcedure;
     
                     // AÃ±ade los parÃ¡metros esperados por el procedimiento almacenado.
                     command.Parameters.AddWithValue("@DisponibilidadID", disponibilidadTecnico.DisponibilidadID);
                     command.Parameters.AddWithValue("@TecnicoID", disponibilidadTecnico.TecnicoID);
                     command.Parameters.AddWithValue("@Fecha", disponibilidadTecnico.Fecha ?? string.Empty);
                     command.Parameters.AddWithValue("@HoraInicio", disponibilidadTecnico.HoraInicio ?? string.Empty);
                     command.Parameters.AddWithValue("@HoraFin", disponibilidadTecnico.HoraFin ?? string.Empty);
     
                     // AÃ±ade un parÃ¡metro para recibir el valor de retorno del procedimiento almacenado.
                     var returnParameter = command.Parameters.Add("@ReturnVal", SqlDbType.Int);
                     returnParameter.Direction = ParameterDirection.ReturnValue;
     
                     command.ExecuteNonQuery();
     
                     int result = (int)returnParameter.Value;
                     if (result == 0)
                     {
                         // Manejar el caso en el que no se actualice ningÃºn registro, podrÃ­a ser que el TecnicoID no exista.
                         Console.WriteLine("No se encontrÃ³ la disponibilidad para actualizar.");
                     }
                     else
                     {
                         Console.WriteLine("Disponibilidad actualizada con Ã©xito.");
                     }
                 }
                 catch (SqlException ex)
                 {
                     // Maneja la excepciÃ³n de SQL aquÃ­.
                     Console.WriteLine($"OcurriÃ³ un error de SQL: {ex.Message}");
                 }
                 catch (Exception ex)
                 {
                     // Maneja cualquier otro tipo de excepciÃ³n aquÃ­.
                     Console.WriteLine($"OcurriÃ³ un error inesperado: {ex.Message}");
                 }
             }
     
             public void DeleteDisponibilidadTecnico(int disponibilidadTecnicoId)
             {
                 try
                 {
                     using var connection = new SqlConnection(_connectionString);
     
                     connection.Open();
     
                     using var command = new SqlCommand("EliminarDisponibilidadTecnico", connection);
     
                     // Especifica que el tipo de comando es un procedimiento almacenado.
                     command.CommandType = CommandType.StoredProcedure;
     
                     // AÃ±ade los parÃ¡metros esperados por el procedimiento almacenado.
                     command.Parameters.AddWithValue("@DisponibilidadID", disponibilidadTecnicoId);
     
                     // AÃ±ade un parÃ¡metro para recibir el valor de retorno del procedimiento almacenado.
                     var returnParameter = command.Parameters.Add("@ReturnVal", SqlDbType.Int);
                     returnParameter.Direction = ParameterDirection.ReturnValue;
     
                     command.ExecuteNonQuery();
     
                     int result = (int)returnParameter.Value;
                     if (result == 0)
                     {
                         // Manejar el caso en el que no se elimine ningÃºn registro, podrÃ­a ser que el TecnicoID no exista.
                         Console.WriteLine("No se encontrÃ³ la disponibilidad para eliminar.");
                     }
                     else
                     {
                         Console.WriteLine("Disponibilidad eliminada con Ã©xito.");
                     }
                 }
                 catch (SqlException ex)
                 {
                     // Maneja la excepciÃ³n de SQL aquÃ­.
                     Console.WriteLine($"OcurriÃ³ un error de SQL: {ex.Message}");
                 }
                 catch (Exception ex)
                 {
                     // Maneja cualquier otro tipo de excepciÃ³n aquÃ­.
                     Console.WriteLine($"OcurriÃ³ un error inesperado: {ex.Message}");
                 }
             }
         }
     }
     */

     TecnicoRepository.cs
     /*
     ï»¿using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Threading.Tasks;
     using Microsoft.Data.SqlClient;
     using FugasDetectionSystem.Domain.Entities;
     using FugasDetectionSystem.Domain.Interfaces;
     using FugasDetectionSystem.Infrastructure.repositories;
     using FugasDetectionSystem.Infrastructure.Exceptions;
     
     namespace FugasDetectionSystem.Domain.Repositories
     {
         public class TecnicoRepository(IDatabaseSettings databaseSettings) : BaseRepository(databaseSettings), ITecnicoRepository
         {
             private static Tecnico MapToTecnico(SqlDataReader reader)
             {
                 return new Tecnico
                 {
                     TecnicoID = reader.GetInt32(reader.GetOrdinal("TecnicoID")),
                     Nombre = reader.IsDBNull(reader.GetOrdinal("Nombre")) ? string.Empty : reader.GetString(reader.GetOrdinal("Nombre")),
                     Apellido = reader.IsDBNull(reader.GetOrdinal("Apellido")) ? string.Empty : reader.GetString(reader.GetOrdinal("Apellido")),
                     Especialidad = reader.IsDBNull(reader.GetOrdinal("Especialidad")) ? string.Empty : reader.GetString(reader.GetOrdinal("Especialidad")),
                     CorreoElectronico = reader.IsDBNull(reader.GetOrdinal("CorreoElectronico")) ? string.Empty : reader.GetString(reader.GetOrdinal("CorreoElectronico")),
                     Telefono = reader.IsDBNull(reader.GetOrdinal("Telefono")) ? string.Empty : reader.GetString(reader.GetOrdinal("Telefono"))
                 };
             }
     
             public async Task<IEnumerable<Tecnico>> GetAllAsync()
             {
                 var tecnicos = new List<Tecnico>();
     
                 try
                 {
                     using var connection = GetOpenConnection();
                     using var command = CreateCommand(connection, "ConsultarTecnicos");
                     using var reader = await command.ExecuteReaderAsync();
     
                     while (await reader.ReadAsync())
                     {
                         tecnicos.Add(MapToTecnico(reader));
                     }
                 }
                 catch (Exception ex)
                 {
                     HandleException(ex);
                 }
     
                 return tecnicos;
             }
     
             public async Task<Tecnico> GetByIdAsync(int tecnicoId)
             {
                 Tecnico tecnico = null;
     
                 try
                 {
                     using var connection = GetOpenConnection();
                     using var command = CreateCommand(connection, "ConsultarTecnicoPorID");
                     command.Parameters.AddWithValue("@TecnicoID", tecnicoId);
     
                     using var reader = await command.ExecuteReaderAsync();
     
                     if (await reader.ReadAsync())
                     {
                         tecnico = MapToTecnico(reader);
                     }
                 }
                 catch (Exception ex)
                 {
                     HandleException(ex);
                 }
     
                 return tecnico;
             }
     
             public async Task AddAsync(Tecnico tecnico)
             {
                 try
                 {
                     using var connection = GetOpenConnection();
                     using var command = CreateCommand(connection, "InsertarTecnico");
     
                     // AÃ±ade los parÃ¡metros esperados por el procedimiento almacenado.
                     command.Parameters.AddWithValue("@Nombre", tecnico.Nombre ?? string.Empty);
                     command.Parameters.AddWithValue("@Apellido", tecnico.Apellido ?? string.Empty);
                     command.Parameters.AddWithValue("@Especialidad", tecnico.Especialidad ?? string.Empty);
                     command.Parameters.AddWithValue("@CorreoElectronico", tecnico.CorreoElectronico ?? string.Empty);
                     command.Parameters.AddWithValue("@Telefono", tecnico.Telefono ?? string.Empty);
     
                     var returnParameter = command.Parameters.Add("@ReturnVal", SqlDbType.Int);
                     returnParameter.Direction = ParameterDirection.ReturnValue;
     
                     await command.ExecuteNonQueryAsync();
     
                     int result = (int)returnParameter.Value;
                     // Manejar el resultado como sea necesario
                 }
                 catch (Exception ex)
                 {
                     HandleException(ex);
                 }
             }
     
             public async Task UpdateAsync(Tecnico tecnico)
             {
                 try
                 {
                     using var connection = GetOpenConnection();
                     using var command = CreateCommand(connection, "ActualizarTecnico");
     
                     // Especifica que el tipo de comando es un procedimiento almacenado y aÃ±ade los parÃ¡metros.
                     command.Parameters.AddWithValue("@TecnicoID", tecnico.TecnicoID);
                     command.Parameters.AddWithValue("@Nombre", tecnico.Nombre);
                     command.Parameters.AddWithValue("@Apellido", tecnico.Apellido );
                     command.Parameters.AddWithValue("@Especialidad", tecnico.Especialidad);
                     command.Parameters.AddWithValue("@CorreoElectronico", tecnico.CorreoElectronico);
                     command.Parameters.AddWithValue("@Telefono", tecnico.Telefono);
     
                     var returnParameter = command.Parameters.Add("@ReturnVal", SqlDbType.Int);
                     returnParameter.Direction = ParameterDirection.ReturnValue;
     
                     await command.ExecuteNonQueryAsync();
     
                     int result = (int)returnParameter.Value;
                     // Manejar el resultado como sea necesario
                 }
                 catch (Exception ex)
                 {
                     HandleException(ex);
                 }
             }
     
             public async Task DeleteAsync(int tecnicoId)
             {
                 try
                 {
                     using var connection = GetOpenConnection();
                     using var command = CreateCommand(connection, "EliminarTecnico");
     
                     command.Parameters.AddWithValue("@TecnicoID", tecnicoId);
     
                     var returnParameter = command.Parameters.Add("@ReturnVal", SqlDbType.Int);
                     returnParameter.Direction = ParameterDirection.ReturnValue;
     
                     await command.ExecuteNonQueryAsync();
     
                     int result = (int)returnParameter.Value;
                     // Manejar el resultado como sea necesario
                 }
                 catch (Exception ex)
                 {
                     HandleException(ex);
                 }
             }
         }
     }
     */

   Services/
     Telegram/
       Handlers/
         TelegramHandlers.cs
         /*
         ï»¿using Telegram.Bot;
         using Telegram.Bot.Types;
         
         namespace FugasDetectionSystem.Infrastructure.Services.Telegram.Handlers
         {
             public delegate Task UpdateHandler(ITelegramBotClient botClient, Update update, CancellationToken cancellationToken);
             public delegate Task ErrorHandler(ITelegramBotClient botClient, Exception exception, CancellationToken cancellationToken);
         }
         */

       Interfaces/
         ITelegramBotService.cs
         /*
         ï»¿using FugasDetectionSystem.Infrastructure.Services.Telegram.Handlers;
         
         namespace FugasDetectionSystem.Infrastructure.Services.Telegram.Interfaces
         {
             public interface ITelegramBotService
             {
                 void StartReceiving(UpdateHandler updateHandler, ErrorHandler errorHandler);
                 void StopReceiving();
             }
         }
         */

       TelegramBotService.cs
       /*
       ï»¿using Telegram.Bot;
       using Telegram.Bot.Polling;
       using Telegram.Bot.Types.Enums;
       using FugasDetectionSystem.Infrastructure.Services.Telegram.Handlers;
       using FugasDetectionSystem.Infrastructure.Services.Telegram.Interfaces;
       
       namespace FugasDetectionSystem.Infrastructure.Services.Telegram
       {
           public class TelegramBotService(string token) : ITelegramBotService
           {
               private readonly TelegramBotClient _botClient = new(token);
               private readonly CancellationTokenSource _cts = new();
       
               public void StartReceiving(UpdateHandler updateHandler, ErrorHandler errorHandler)
               {
                   var receiverOptions = new ReceiverOptions
                   {
                       AllowedUpdates = [] // Recibe todos los tipos de actualizaciones
                   };
       
                   _botClient.StartReceiving(
                       updateHandler: (botClient, update, ct) => updateHandler.Invoke(botClient, update, ct),
                       pollingErrorHandler: (botClient, exception, ct) => errorHandler.Invoke(botClient, exception, ct),
                       receiverOptions: receiverOptions,
                       cancellationToken: _cts.Token
                   );
       
               }
       
               public void StopReceiving()
               {
                   _cts.Cancel();
               }
           }
       }
       */

 _Certificado/
